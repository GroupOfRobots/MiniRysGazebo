#!/usr/bin/env python3
import os
import time
import random

import launch
import logging

from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont
from PIL import ImageEnhance

from dataclasses import dataclass
from typing import List
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, OpaqueFunction, SetEnvironmentVariable, DeclareLaunchArgument
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, EnvironmentVariable
import xml.etree.ElementTree as ET



@dataclass
class RobotParameters:
    robot_namespace: str = 'robot'
    color_code: str = '#9370DB'
    camera_enabled: str = 'true'
    camera_visibility: str = 'false'
    label_enabled: str = 'true'
    label_x: str = '0.13'
    label_y: str = '0.05'
    TOF_enabled: str = 'false'
    horizontal_sensor_visibility: str = 'false'
    vertical_sensor_visibility: str = 'false'
    all_sensor_visibility: str = 'false'
    TOF_FOV_angle: str = '0.08'
    TOF_range: str = '5'
    spawn_x: str = '-2.0'
    spawn_y: str = '-3.0'
    spawn_z: str = '0.056'
    spawn_roll: str = '0.0'
    spawn_pitch: str = '0.0'
    spawn_yaw: str = '1.570796327'
    chassis_mu1: str = '0.0'
    chassis_mu2: str = '0.0'
    chassis_kp: str = '10000000.0'
    chassis_kd: str = '1.0'
    wheel_mu1: str = '10.0'
    wheel_mu2: str = '10.0'
    wheel_kp: str = '10000000.0'
    wheel_kd: str = '1.0'
    wheel_joint_dumping: str = '0.0001'
    wheel_joint_friction: str = '0.0001'
    chassis_mx: str = '0.0'
    chassis_my: str = '0.0'
    chassis_mz: str = '0.015152'
    chassis_ixx: str = '0.002829167'
    chassis_ixy: str = '0.0'
    chassis_ixz: str = '0.0'
    chassis_iyy: str = '0.002829167'
    chassis_iyz: str = '0.0'
    chassis_izz: str = '0.3625'
    wheels_ixx: str = '0.00013418'
    wheels_ixy: str = '0.0'
    wheels_ixz: str = '0.0'
    wheels_iyy: str = '0.00013418'
    wheels_iyz: str = '0.0'
    wheels_izz: str = '0.00026198'


@dataclass
class SpawnParameters:
    robots_number: int = 1
    number_of_rows: int = 1

    use_gradient_color: bool = True      # 1//      if 1 = T, 2 = T -> ERROR (use all white),         if 1 = F, 2 = T -> randomize colors,
    randomize_colors: bool = False       # 2//      if 1 = T, 2 = F -> color generated by params,     if 1 = F, 2 = F -> all the same (as starting color), 
    gradient_starting_color: str = "#000000"
    gradient_color_step: str = "#020202"

    x_separation: float = 0.0
    y_separation: float = 0.0
    z_separation: float = 0.0
    x_offset: float = -5.0
    y_offset: float = -5.0
    z_offset: float = 0.0
    roll: float = 0.0
    pitch: float = 0.0
    yaw: float = 1.570796327


def generate_label_texture(package_path, robot_params_list, parameters_to_display, values_of_parameters):
    # Important variables
    pixel_size = 0.00025
    offset_from_corners = 38
    color = '#FFF'
    large_font_size = 56
    small_font_size = 28

    # Deleting all "robotX.png" files from the "textures" directory
    directory = f'{package_path}/description/materials/scripts/textures'
    for filename in os.listdir(directory):
        if filename.startswith("robot") and filename.endswith(".png"):
            os.remove(os.path.join(directory, filename))

    # Load the fonts
    font_large = ImageFont.truetype(font=f'{package_path}/description/materials/scripts/textures/font.ttf', size=large_font_size)
    font_small = ImageFont.truetype(font=f'{package_path}/description/materials/scripts/textures/font.ttf', size=small_font_size)
    

    for idx, robot_params in enumerate(robot_params_list):
        # Create the text lines
        robot_number = robot_params.robot_namespace.replace('robot', '')
        nicer_robot_name = f"Robot {robot_number}"
        text_lines = [(f"{nicer_robot_name}", font_large)]
        for param, value in zip(parameters_to_display, values_of_parameters[idx]):
            if param == 'color_code':
                text_lines.append((f"color_code: {robot_params_list[idx].color_code}", font_small))
            else:
                text_lines.append((f"{param}: {value}", font_small))

        # Calculate the size of the box
        tmp_img = Image.new('RGB', (1, 1))
        line_sizes = [ImageDraw.Draw(tmp_img).textsize(text, font=font) for text, font in text_lines]
        box_width = max(width for width, _ in line_sizes) + offset_from_corners*2
        box_height = sum(height for _, height in line_sizes) + offset_from_corners*2
        charsize = (box_width, box_height)

        # Update the robot parameters
        robot_params.label_x = str(box_width * pixel_size)
        robot_params.label_y = str(box_height * pixel_size)

        # Create the image
        bg_img = Image.new('RGB', charsize, color)
        mask_img = Image.new('L', bg_img.size, 0)
        draw = ImageDraw.Draw(mask_img)
        total_height = offset_from_corners - 9

        for line, font in text_lines:
            text_width, text_height = draw.textsize(line, font=font)
            draw.text(((charsize[0]-text_width)//2, total_height), line, font=font, fill='white')
            total_height += text_height
        bg_img.putalpha(mask_img)

        # Save the image
        texture_name = f"{robot_params.robot_namespace}.png"
        bg_img.save(f'{package_path}/description/materials/scripts/textures/' + texture_name)

        # Update the textures.material file
        with open(f"{package_path}/description/materials/scripts/textures.material", 'r') as file:
            lines = file.readlines()

        line_to_find = f"                texture textures/{texture_name}\n"

        if line_to_find not in lines:
            print(f"Creating {robot_params.robot_namespace} texture description")
            with open(f"{package_path}/description/materials/scripts/textures.material", 'a') as file:
                file.write("\n")
                file.write(f"material rys/{robot_params.robot_namespace}\n")
                file.write("{\n")
                file.write("    technique\n")
                file.write("    {\n")
                file.write("        pass\n")
                file.write("        {\n")
                file.write("            scene_blend alpha_blend\n")
                file.write("            depth_write off\n")
                file.write("            lighting off\n")
                file.write("            texture_unit\n")
                file.write("            {\n")
                file.write(f"                texture textures/{texture_name}\n")
                file.write("            }\n")
                file.write("        }\n")
                file.write("    }\n")
                file.write("}\n")

def generate_color_names(params: SpawnParameters):
    if params.use_gradient_color and params.randomize_colors:
        raise ValueError("[SIM ERROR] 00 Both gradient and randomize options cannot be True.")

    color_names = []

    # Get the gradient color step as RGB
    step_r, step_g, step_b = hex_to_rgba(params.gradient_color_step)
    print(f"\nparam: use gradient {params.use_gradient_color}, randomize: {params.randomize_colors}")

    if params.use_gradient_color and ~params.randomize_colors:
        # print("1")
        for i in range(params.robots_number):
            # Get starting value as RGB
            r, g, b = hex_to_rgba(params.gradient_starting_color)
            r = (float(r) + i * float(step_r)) 
            g = (float(g) + i * float(step_g))
            b = (float(b) + i * float(step_b))
            if r > 1.0: r = r % 1.0
            if g > 1.0: g = g % 1.0
            if b > 1.0: b = b % 1.0
            color_names.append(f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}")
    elif params.randomize_colors:
        # print("2")
        for i in range(params.robots_number):
            r = random.random()
            g = random.random()
            b = random.random()
            color_names.append(f"#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}")
    else:
        # print("3")
        color_names = [params.gradient_starting_color]
    print(f"\ncolor_list: {color_names}\n")
    return color_names

# Function for converting hexadecimal color to RGB
def hex_to_rgba(hex_string):
    hex_string = hex_string.lstrip('#')
    if len(hex_string) != 6:
        raise ValueError("[SIM ERROR] 00 Input hexadecimal is not in correct format")
    r, g, b = (int(hex_string[i:i+2], 16) for i in (0, 2, 4))
    return str(r/255), str(g/255), str(b/255)

def generate_robot_data(package_path, simulation_params: SpawnParameters, param_to_change, iterate_by, start_from):
    """
    Generates a list of robot parameters based on the provided spawn parameters.

    Args:
        simulation_params (SpawnParameters): The spawn position parameters for the robots.
        param_to_change (List[str]): A list of parameter names to set for each robot.
        iterate_by (List[float]): A list of values for each parameter from param_to_change list that should be added to the subsequent robots that will be spawned.
        start_from (List[float]): A list of starting values for each parameter in the `param_to_change` to which iterate_by will be added. (the first values for each parameter in the param_to_change list)

    Returns:
        List[RobotParameters]: A list of robot parameters based on the provided configuration.

    """
    # True offset calculation
    simulation_params.x_offset = (-simulation_params.x_separation * (simulation_params.robots_number/simulation_params.number_of_rows - 1.0) / 2.0) + simulation_params.x_offset
    simulation_params.y_offset = simulation_params.y_offset + 1.0

    # VARIABLES
    # Initialize the list of robot parameters
    robot_params_list = []
    # Initialize the list of values to display in the label
    values_to_display = []

    # Check if the number of robots is bigger than zero. If not, return an empty list (error case)
    if simulation_params.robots_number <= 0:
        print(f"[SIM ERROR] 00 No robot to be spawned. simulation_params.robots_number = {simulation_params.robots_number}. To spawn a robot, this value must be an integer bigger than zero")
        return [], []
    
    # Upload the color names from the color_list.txt file
    color_name_list = generate_color_names(simulation_params)
    print(color_name_list)
    if len(color_name_list) == 0:
        print("[SIM ERROR] 00 No colors found in the color list.")
        return [], []

    row = 0 # row number, used to calculate the y position of the robot
    column = 0 # column number, used to calculate the x position of the robot
    
    # Check if the number of rows is bigger than the number of robots. If so, set the number of rows to 1
    if simulation_params.number_of_rows > simulation_params.robots_number:
        robots_per_row = simulation_params.robots_number
        print(f"[SIM WARN] 00 The number of rows is bigger than the number of robots. The number of rows will be set to 1")
    else:
        robots_per_row = simulation_params.robots_number / simulation_params.number_of_rows # calculate the number of robots per row

    # Iterate over the number of robots and generate the parameters for each robot
    for i in range(simulation_params.robots_number):
        if i % robots_per_row == 0: # if i is a multiple of robots_per_row, increment the row number and reset the column number
            row += 1    # increment the row number
            column = 0  # reset the column number
           
        # Generate the parameters for the robot
        robot_params = RobotParameters(
                robot_namespace = f"robot{i + 1}",
                color_code= f"{color_name_list[i % len(color_name_list)]}",
                spawn_x = f"{simulation_params.x_offset + column * simulation_params.x_separation}",
                spawn_y = f"{simulation_params.y_offset - row + i * simulation_params.y_separation}",
                spawn_z = f"{simulation_params.z_offset + i * simulation_params.z_separation}",
                spawn_roll = f"{simulation_params.roll}",
                spawn_pitch = f"{simulation_params.pitch}",
                spawn_yaw = f"{simulation_params.yaw}",
        )

        
        new_value_list = []
        print(f"param_to_change: {param_to_change}")
        # If param_to_change and iterate_by and start_from: # if the lists are not empty
        if len(param_to_change) == len(iterate_by) == len(start_from): # if the lists have the same number of elements. Which is required
            # For each robot generate the parameters that should be changed
            for j in range(len(param_to_change)): # Iterate over the list of parameters to change
                try: # Try to set the attribute
                    getattr(robot_params, param_to_change[j])
                    new_value = start_from[j] + i * iterate_by[j]
                    new_value_list.append(new_value)
                    setattr(robot_params, param_to_change[j], f"{new_value}")
                    print(f"[SIM INFO] 00 For robot{i+1} attribute {param_to_change[j]} is set to {new_value}.") # TODO: Uncomment this line after testing
                except AttributeError: # If the attribute doesn't exist in the RobotParameters class (error case)
                    print(f"[SIM ERROR] 00 Attribute {param_to_change[j]} not found in RobotParameters class.")
                    return [], []
                except TypeError: # If the attribute is not a float (error case)
                    print(f"[SIM ERROR] 00 Incorrect data type for {param_to_change[j]}.")
                    return [], []
        else:   # If the lists doesn't have the same number of elements (error case)
            print("[SIM ERROR] 00 The lists doesn't contain the same number of parameters.")
            return [], []
 
        column += 1
        values_to_display.append(new_value_list)
        robot_params_list.append(robot_params)
    
    return robot_params_list, values_to_display

def spawn(context, package_path, robot_params: RobotParameters):
    """
    Spawns a robot in the simulation using the provided robot parameters.

    This function sets up the robot launch description using the given
    robot parameters.

    Args:
        context (OpaqueFunction): The context object for the OpaqueFunction, used to pass information
                                  and launch configurations between different parts of the launch system.
        robot_params (RobotParameters): A dataclass object containing the robot's configuration parameters.

    Returns:
        IncludeLaunchDescription: The launch description for spawning the robot with the given parameters.
    """
        
    package_name = 'minirys_sim'
    package_path = get_package_share_directory(package_name)
    
    spawn_another = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(os.path.join(package_path, 'launch', 'robot.launch.py')),
        launch_arguments={
            'robot_namespace': robot_params.robot_namespace,
            'color_code': robot_params.color_code,
            'camera_enabled': robot_params.camera_enabled,
            'camera_visibility': robot_params.camera_visibility,
            'label_enabled': robot_params.label_enabled,
            'label_x': robot_params.label_x,
            'label_y': robot_params.label_y,
            'TOF_enabled':robot_params.TOF_enabled,
            'horizontal_sensor_visibility':robot_params.horizontal_sensor_visibility,
            'vertical_sensor_visibility':robot_params.vertical_sensor_visibility,
            'all_sensor_visibility':robot_params.all_sensor_visibility,
            'TOF_FOV_angle':robot_params.TOF_FOV_angle,
            'TOF_range':robot_params.TOF_range,
            'spawn_x': robot_params.spawn_x,
            'spawn_y': robot_params.spawn_y, 
            'spawn_z': robot_params.spawn_z, 
            'spawn_roll': robot_params.spawn_roll, 
            'spawn_pitch': robot_params.spawn_pitch, 
            'spawn_yaw': robot_params.spawn_yaw,
            'chassis_mu1': robot_params.chassis_mu1,
            'chassis_mu2': robot_params.chassis_mu2,
            'chassis_kp': robot_params.chassis_kp,
            'chassis_kd': robot_params.chassis_kd,
            'wheel_mu1': robot_params.wheel_mu1,
            'wheel_mu2': robot_params.wheel_mu2,
            'wheel_kp': robot_params.wheel_kp,
            'wheel_kd': robot_params.wheel_kd,
            'wheel_joint_dumping': robot_params.wheel_joint_dumping,
            'wheel_joint_friction': robot_params.wheel_joint_friction,
            'chassis_mx': robot_params.chassis_mx,
            'chassis_my': robot_params.chassis_my,
            'chassis_mz': robot_params.chassis_mz,
            'chassis_ixx': robot_params.chassis_ixx,
            'chassis_ixy': robot_params.chassis_ixy,
            'chassis_ixz': robot_params.chassis_ixz,
            'chassis_iyy': robot_params.chassis_iyy,
            'chassis_iyz': robot_params.chassis_iyz,
            'chassis_izz': robot_params.chassis_izz,
            'wheels_ixx': robot_params.wheels_ixx,
            'wheels_ixy': robot_params.wheels_ixy,
            'wheels_ixz': robot_params.wheels_ixz,
            'wheels_iyy': robot_params.wheels_iyy,
            'wheels_iyz': robot_params.wheels_iyz,
            'wheels_izz': robot_params.wheels_izz,
        }.items()
    )

    return [spawn_another]

def launch_gazebo_world(context, world_name: str):
     
    package_name = 'minirys_sim'
    package_path = get_package_share_directory(package_name)
    
    launch_gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(os.path.join(package_path, 'launch', 'world.launch.py')),
        launch_arguments={
            'world_name': world_name
        }.items()
    )

    return [launch_gazebo] 

def populate_sim_params(package_path, mode):
    simulation_params = SpawnParameters()
    tree = ET.parse(f"{package_path}/config/launch_config.xml")
    root = tree.getroot()

    # Find the spawn_parameters element with the specified mode attribute
    spawn_params_elem = root.find(f"spawn_parameters[@mode='{mode}']")

    simulation_params.robots_number = int(spawn_params_elem.find("robots_number").text)
    simulation_params.number_of_rows = int(spawn_params_elem.find("number_of_rows").text)
    simulation_params.use_gradient_color = spawn_params_elem.find("use_gradient_color").text == "True" #   For bool we need to check if the string is equal True
    simulation_params.randomize_colors = spawn_params_elem.find("randomize_colors").text == "True" #       Because bool gives True always when string isn't empty
    simulation_params.gradient_starting_color = str(spawn_params_elem.find("gradient_starting_color").text) 
    simulation_params.gradient_color_step = str(spawn_params_elem.find("gradient_color_step").text)
    simulation_params.x_separation = float(spawn_params_elem.find("x_separation").text)
    simulation_params.y_separation = float(spawn_params_elem.find("y_separation").text)
    simulation_params.z_separation = float(spawn_params_elem.find("z_separation").text)
    simulation_params.x_offset = float(spawn_params_elem.find("x_offset").text)
    simulation_params.y_offset = float(spawn_params_elem.find("y_offset").text)
    simulation_params.z_offset = float(spawn_params_elem.find("z_offset").text)
    simulation_params.roll = float(spawn_params_elem.find("roll").text)
    simulation_params.pitch = float(spawn_params_elem.find("pitch").text)
    simulation_params.yaw = float(spawn_params_elem.find("yaw").text)

    param_to_change = [elem.text for elem in root.find("param_to_change").findall("value")]
    start_from = [float(elem.text) for elem in root.find("start_from").findall("value")]
    iterate_by = [float(elem.text) for elem in root.find("iterate_by").findall("value")]

    print(f"param_to_change: {param_to_change}")
    print(f"start_from: {start_from}")
    print(f"iterate_by: {iterate_by}")
    
    return param_to_change, start_from, iterate_by, simulation_params

def save_configs_to_xml(package_path: str, robot_params_list: List[RobotParameters]):
    for robot_params in robot_params_list:
        root = ET.Element("robot_config")

        for param_name, param_value in robot_params.__dict__.items():
            param_elem = ET.SubElement(root, param_name)
            param_elem.text = str(param_value)

        # Save the XML to a file with the specified name format
        file_path = f"{package_path}/config/robots/{robot_params.robot_namespace}_config.xml"
        
        # Use pretty_xml to format the XML content
        formatted_xml = format_xml(root)
        
        with open(file_path, "w", encoding="utf-8") as f:
            f.write('<?xml version="1.0" encoding="utf-8"?>\n')
            f.write(formatted_xml)

def format_xml(element, level = 0):
    indent = '    ' * level
    result = [indent + '<' + element.tag]
    
    # Add attributes
    for name, value in sorted(element.attrib.items()):
        result.append(f' {name}="{value}"')
    
    # Add text content
    if element.text:
        content = element.text.strip()
        if content:
            result.append('>' + content)
    else:
        result.append('>\n')

    # Add children elements
    for child in element:
        result.append(format_xml(child, level + 1))

    # Add closing tag
    result.append('</' + element.tag + '>\n')

    return ''.join(result)

def remove_files_from_folder(folder_path):
    # Check if the folder exists before trying to remove files
    if os.path.isdir(folder_path):
        # List all files in the folder
        files = os.listdir(folder_path)
        # Iterate through the files and remove them
        for file in files:
            file_path = os.path.join(folder_path, file)

            # Check if it's a file (not a directory)
            if os.path.isfile(file_path):
                os.remove(file_path)
            else:
                print(f'{file_path} is not a file.')

    else:
        print(f'Folder {folder_path} not found.')

def read_color_names_from_file(file_path):
    color_name_list = []

    with open(file_path, 'r') as file:
        in_color_list = False
        for line in file:
            line = line.strip()
            if not in_color_list:
                if line == '<color_list>':
                    in_color_list = True
            else:
                if line == '</color_list>':
                    break
                color_name_list.append(line)

    return color_name_list

def generate_launch_description():
    """
    Generates a launch description for spawning robots in the simulation.

    This function sets up the spawn parameters for the robots, generates
    the robot parameters based on the specified configuration, and spawns
    the robots in the simulation using the generated parameters.

    Returns:
        LaunchDescription: A launch description containing the actions for
                           creating the simulation world and spawning the 
                           defined robots.
    """
    script_path = os.path.abspath(__file__)
    package_path = os.path.dirname(script_path).replace("/install/minirys_sim/share/minirys_sim/launch", "/src/minirys_sim")

    ########################################################################
    ############################### SETUP ##################################
    ########################################################################
    simulation_params = SpawnParameters()
    mode = "row_spawn_parameters"
    param_to_change, start_from, iterate_by, simulation_params = populate_sim_params(package_path, mode)
    print(simulation_params.gradient_starting_color)

    robot_params_list, values_to_display = generate_robot_data(package_path, simulation_params, param_to_change, iterate_by, start_from)
    if not robot_params_list: # Check if the list is empty (error case)
        print("[SIM ERROR] 00 Terminating launch sequence...")
        return LaunchDescription([])
    

    reload_xmls = True
    if reload_xmls:
            remove_files_from_folder(f"{package_path}/config/robots")
    # Save the robot parameters to XML files
    save_configs_to_xml(package_path, robot_params_list)

    # Add the color code to the list of parameters to display and values to display
    param_to_display = ['color_code']
    for i in range (len(param_to_change)):
        param_to_display.append(param_to_change[i])
    for i in range (len(values_to_display)):    
        values_to_display[i].insert(0, 0)

    param_to_change = param_to_display

    
    generate_label_texture(package_path, robot_params_list, param_to_change, values_to_display)
    
    ########################################################################

    spawn_actions = []
    for i in range(len(robot_params_list)):
        spawn_actions.append(
            OpaqueFunction(
                function=spawn,
                kwargs={
                    'package_path': package_path,
                    'robot_params': robot_params_list[i]
                },
            )
        )


    launch.logging.get_logger().setLevel(logging.WARNING)

    return LaunchDescription([
        SetEnvironmentVariable("RCUTILS_LOGGING_SEVERITY_THRESHOLD", "30"),
    ] + spawn_actions)


